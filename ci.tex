\section{Continuous Integration}

\emph{Continuous Integration} (CI) and \emph{Continuous Deployment} (CD) are a critical component of a modern software system and modern astronomical observatory.\cite{2014arXiv1407.6463E}

\subsection{Jenkins}
\label{sec:jenkins}

The initial CI system used for pre-merge testing of
science pipeline code was \href{https://buildbot.net/}{Buildbot}.
In 2014 it was able to accomplish the basic task of building branches from a git repo,
but there were a number of drawbacks.
For example, the UI was spartan and difficult to navigate, there was no
integration with 3rd party authentication systems requiring manual management
of user accounts, bare-bones ``out of the box'' functionality without a useful
selection of publicly available plugins, and DM internal concern as to the long
term viability of the product as there appeared be relatively few public/open source users
relative to competing CI/CD systems.

% should this be broken into a \item list? No. Not enough space.
After evaluating several potential CI/CD systems as a replacement,
\href{https://jenkins.io/}{Jenkins} was selected for numerous reasons, including:
an open source core, it could be self hosted (the wall-clock build
time and memory requirements exceeded the limits of many of the commercial
hosted CI options, at that time), it offered an improved UI over Buildbot,
there was a pre-existing plugin to use \href{https://plugins.jenkins.io/github-oauth}{GitHub OAuth},
a healthy extension ecosystem with many useful plugins, apparent popularity with self-hosted
open source projects, and an active core project.

\subsubsection{Configuration \& Deployment}

The Jenkins core and various plugins need to be version managed and configured.
Although there is currently a major effort underway to add native
``\href{https://github.com/jenkinsci/configuration-as-code-plugin}{configuration by code}'' to
the Jenkins core, this is not yet considered production ready and did not exist
at the time DM was transitioning away from Buildbot.

\href{https://puppet.com/}{Puppet} was selected as a configuration management (CM) tool as, at that time, it had the most sophisticated Jenkins
management abilities among the CM tools surveyed via the \href{https://github.com/voxpupuli/puppet-jenkins}{\texttt{puppet-jenkins}} module.
Non-trivial improvements have been contributed by DM staff to this module\cite{puppetconf-jenkins} in order to make it more suitable for managing a Jenkins deployment.

Configuration of Jenkins jobs is handled via the \href{https://plugins.jenkins.io/job-dsl}{\texttt{job-dsl}} plugin.
This enables a \href{http://www.groovy-lang.org/}{\texttt{groovy}} based DSL and a special job type that
will ``seed'' Jenkins jobs from a git repository that contains \texttt{job-dsl}
script(s).  The seed job itself is maintained as XML that is manually
installed by puppet.  The result is that all jobs configuration is managed via
source code management and no manual configuration via the Jenkins UI is required to
add/delete/change or stand up a testing environment.

% should any of the jenkins related repos be mentioned?
% the production jenkins deployment is not publically accessible

% add discussion of jenkins pipeline

\subsubsection{Evolving Usage}

Over time, usage of Jenkins has evolved from being used solely for pre-merge
CI testing to automation of a number of common tasks.  Among various sundry
tasks, it is being used to build Docker images, update local software mirrors, and
schedule regular backups.  Perhaps most notably, it is being used to drive a
CD workflow for completely automated nightly and weekly
release/publication of science pipelines codes (\ref{sec:scipipe-deploy}).

\subsection{Travis-CI}
\label{sec:travis-ci}

In addition to Jenkins, we also use the Travis integration provided by GitHub.
As described in \S\ref{sec:ltd} Travis is used for deployment of our documentation artifacts.
With our non-standard build system we can not use Travis for unit testing our branches in most of our software repositories.
Instead, we use Travis for linting: we validate that important CI configuration files have the correct formatting, and we run the \texttt{flake8} and \texttt{shellcheck} tools on our code.
These Travis checks allow us to enforce our code merging policies (\S\ref{sec:dev_workflow}) by requiring that branches are up to date before merges are allowed.
GitHub only enables this if a Travis job is executed.
